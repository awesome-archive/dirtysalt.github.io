#+title: Software Engineering at Google

** Introduction
** Software development
*** The source repository
关于Google代码仓库详情，可以参考文章 [[file:../why-google-stores-billions-of-lines-of-code-in-a-single-repository.org][Why Google Stores Billions of Lines of Code in a Single Repository]]

除了Chrome和Android两个项目（使用单独的开源仓库），以及一些涉及商业核心机密的代码仓库（限制读取权限），其他所有的代码仓库都是对外公开并且基于trunk开发。

基于trunk的开发可以让问题定位更加容易，并且减少merge的工作量，同时加快代码（和依赖它的代码）的更新和修复速度。

所有的subtree都有几个owners, 只有这些owners对他们负责的subtree有写入权限，其他人如果想要修改的话可以提交PR, 这样确保提交进来的代码质量. owners的数量可多可少，但是至少需要两个而且最好是地理上分开的（比如时区跨度比较大），多的话可能可以是整个team.

尽可能地让所有check in都触发run tests, 来尽快定位问题。一旦没有通过tests，会立刻通知代码的提交者。同时对于大型项目会设置"build cop", 职责是监督整个source tree的build状态确保始终可以build, 一旦发现出现问题，要协助作者修复问题或者是回滚代码。

see [17] [18] [19] [21]

[17]  Why Google Stores Billions of Lines of Code in a Single Repository , Rachel Potvin, presentation. https://www.youtube.com/watch?v=W71BTkUbdqE
[18]  The Motivation for a Monolithic Codebase , Rachel Potvin, Josh Levenberg, to be published in Communications of the ACM, July 2016.
[19]  Scaling Mercurial at Facebook,  Durham Goode, Siddharth P. Agarwa, Facebook blog post, January 7th, 2014. https://code.facebook.com/posts/218678814984400/scaling-mercurial-at-facebook/
[20]  Why We (Still) Believe In Private Offices , David Fullerton, Stack Overflow blog post, January 16th, 2015. https://blog.stackoverflow.com/2015/01/why-we-still-believe-in-private-offices/
[21]  Continuous Integration at Google Scale , John Micco, presentation, EclipseCon, 2013. http://eclipsecon.org/2013/sites/eclipsecon.org.2013/files/2013-03-24%20Continuous%20Integration%20at%20Google%20Scale.pdf


*** The Build System
Blaze构建系统，使用high-level描述式语言编写BUILD文件，根据各个项目提供的BUILD文件解决依赖问题（依赖描述必须是完备的），并且优化编译步骤。

虽然Go语言编译器可以通过分析文件生成BUILD文件，但是这个BUILD通常都是check in到仓库里面，这样可以将编译器和构建工具作用解耦，充分利用Blaze构建系统的强大功能。

建立在几百台甚至上千台机器上的分布式编译系统，可以快速地构建出结果并且同时跑完test cases.

构建系统必须是非常可靠的，并且每个过程都是确定的，比如说要能正确地解决cache问题或者是编译器变动造成的问题等。两个人在不同环境下面，只要BUILD文件是相同的，那么得到的结果也必须是一致的。

因为构建系统对中间结果进行了缓存，所以导致构建速度可以很快很快。一旦构建速度很快，我们就可以做presubmit check。每个subtree都会指定要求presubmit check需要运行哪些test cases, 这个过程可以是同步的（提交PR之前一定要完成），也可以是异步的（先提交PR之后附带run tests结果）

*** Code Review



